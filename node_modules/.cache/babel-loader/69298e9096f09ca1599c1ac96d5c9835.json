{"ast":null,"code":"import sync from 'framesync';\nimport { copyAxisBox } from '../../../utils/geometry/index.js';\nimport { compareByDepth } from '../../utils/compare-by-depth.js';\n\nfunction updateTreeLayoutMeasurements(visualElement) {\n  withoutTreeTransform(visualElement, function () {\n    var allChildren = collectProjectingChildren(visualElement);\n    batchResetAndMeasure(allChildren);\n    updateLayoutMeasurement(visualElement);\n  });\n  visualElement.rebaseProjectionTarget(true, visualElement.measureViewportBox(false));\n}\n\nfunction collectProjectingChildren(visualElement) {\n  var children = [];\n\n  var addChild = function (child) {\n    child.isProjecting() && children.push(child);\n    child.children.forEach(addChild);\n  };\n\n  visualElement.children.forEach(addChild);\n  return children.sort(compareByDepth);\n}\n/**\n * Perform the callback after temporarily unapplying the transform\n * upwards through the tree.\n */\n\n\nfunction withoutTreeTransform(visualElement, callback) {\n  var parent = visualElement.parent;\n  var isEnabled = visualElement.projection.isEnabled;\n  isEnabled && visualElement.resetTransform();\n  parent ? withoutTreeTransform(parent, callback) : callback();\n  isEnabled && visualElement.restoreTransform();\n}\n/**\n * Update the layoutState by measuring the DOM layout. This\n * should be called after resetting any layout-affecting transforms.\n */\n\n\nfunction updateLayoutMeasurement(visualElement) {\n  var layoutState = visualElement.getLayoutState();\n  visualElement.notifyBeforeLayoutMeasure(layoutState.layout);\n  layoutState.isHydrated = true;\n  layoutState.layout = visualElement.measureViewportBox();\n  layoutState.layoutCorrected = copyAxisBox(layoutState.layout);\n  visualElement.notifyLayoutMeasure(layoutState.layout, visualElement.prevViewportBox || layoutState.layout);\n  sync.update(function () {\n    return visualElement.rebaseProjectionTarget();\n  });\n}\n/**\n * Record the viewport box as it was before an expected mutation/re-render\n */\n\n\nfunction snapshotViewportBox(visualElement) {\n  visualElement.prevViewportBox = visualElement.measureViewportBox(false);\n  /**\n   * Update targetBox to match the prevViewportBox. This is just to ensure\n   * that targetBox is affected by scroll in the same way as the measured box\n   */\n\n  visualElement.rebaseProjectionTarget(false, visualElement.prevViewportBox);\n}\n\nfunction batchResetAndMeasure(order) {\n  /**\n   * Write: Reset any transforms on children elements so we can read their actual layout\n   */\n  order.forEach(function (child) {\n    return child.resetTransform();\n  });\n  /**\n   * Read: Measure the actual layout\n   */\n\n  order.forEach(updateLayoutMeasurement);\n}\n\nexport { batchResetAndMeasure, collectProjectingChildren, snapshotViewportBox, updateLayoutMeasurement, updateTreeLayoutMeasurements, withoutTreeTransform };","map":{"version":3,"sources":["C:/TEST-REACT-HR-APP/my-mat-tab/node_modules/framer-motion/dist/es/render/dom/projection/utils.js"],"names":["sync","copyAxisBox","compareByDepth","updateTreeLayoutMeasurements","visualElement","withoutTreeTransform","allChildren","collectProjectingChildren","batchResetAndMeasure","updateLayoutMeasurement","rebaseProjectionTarget","measureViewportBox","children","addChild","child","isProjecting","push","forEach","sort","callback","parent","isEnabled","projection","resetTransform","restoreTransform","layoutState","getLayoutState","notifyBeforeLayoutMeasure","layout","isHydrated","layoutCorrected","notifyLayoutMeasure","prevViewportBox","update","snapshotViewportBox","order"],"mappings":"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","sourcesContent":["import sync from 'framesync';\nimport { copyAxisBox } from '../../../utils/geometry/index.js';\nimport { compareByDepth } from '../../utils/compare-by-depth.js';\n\nfunction updateTreeLayoutMeasurements(visualElement) {\n    withoutTreeTransform(visualElement, function () {\n        var allChildren = collectProjectingChildren(visualElement);\n        batchResetAndMeasure(allChildren);\n        updateLayoutMeasurement(visualElement);\n    });\n    visualElement.rebaseProjectionTarget(true, visualElement.measureViewportBox(false));\n}\nfunction collectProjectingChildren(visualElement) {\n    var children = [];\n    var addChild = function (child) {\n        child.isProjecting() && children.push(child);\n        child.children.forEach(addChild);\n    };\n    visualElement.children.forEach(addChild);\n    return children.sort(compareByDepth);\n}\n/**\n * Perform the callback after temporarily unapplying the transform\n * upwards through the tree.\n */\nfunction withoutTreeTransform(visualElement, callback) {\n    var parent = visualElement.parent;\n    var isEnabled = visualElement.projection.isEnabled;\n    isEnabled && visualElement.resetTransform();\n    parent ? withoutTreeTransform(parent, callback) : callback();\n    isEnabled && visualElement.restoreTransform();\n}\n/**\n * Update the layoutState by measuring the DOM layout. This\n * should be called after resetting any layout-affecting transforms.\n */\nfunction updateLayoutMeasurement(visualElement) {\n    var layoutState = visualElement.getLayoutState();\n    visualElement.notifyBeforeLayoutMeasure(layoutState.layout);\n    layoutState.isHydrated = true;\n    layoutState.layout = visualElement.measureViewportBox();\n    layoutState.layoutCorrected = copyAxisBox(layoutState.layout);\n    visualElement.notifyLayoutMeasure(layoutState.layout, visualElement.prevViewportBox || layoutState.layout);\n    sync.update(function () { return visualElement.rebaseProjectionTarget(); });\n}\n/**\n * Record the viewport box as it was before an expected mutation/re-render\n */\nfunction snapshotViewportBox(visualElement) {\n    visualElement.prevViewportBox = visualElement.measureViewportBox(false);\n    /**\n     * Update targetBox to match the prevViewportBox. This is just to ensure\n     * that targetBox is affected by scroll in the same way as the measured box\n     */\n    visualElement.rebaseProjectionTarget(false, visualElement.prevViewportBox);\n}\nfunction batchResetAndMeasure(order) {\n    /**\n     * Write: Reset any transforms on children elements so we can read their actual layout\n     */\n    order.forEach(function (child) { return child.resetTransform(); });\n    /**\n     * Read: Measure the actual layout\n     */\n    order.forEach(updateLayoutMeasurement);\n}\n\nexport { batchResetAndMeasure, collectProjectingChildren, snapshotViewportBox, updateLayoutMeasurement, updateTreeLayoutMeasurements, withoutTreeTransform };\n"]},"metadata":{},"sourceType":"module"}